<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>HugheX</title>
    <link>https://www.hughex.com/</link>
    <atom:link href="/atom.xml" rel="self" type="application/rss+xml"/>
    
    <description>不想编码</description>
    <pubDate>Thu, 04 Jul 2019 00:37:51 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>浅尝Koa —— 基于Node.JS的下一代Web框架</title>
      <link>https://www.hughex.com/2019/07/04/%E6%B5%85%E5%B0%9DKoa-%E2%80%94%E2%80%94-%E5%9F%BA%E4%BA%8ENode-JS%E7%9A%84%E4%B8%8B%E4%B8%80%E4%BB%A3Web%E6%A1%86%E6%9E%B6/</link>
      <guid>https://www.hughex.com/2019/07/04/%E6%B5%85%E5%B0%9DKoa-%E2%80%94%E2%80%94-%E5%9F%BA%E4%BA%8ENode-JS%E7%9A%84%E4%B8%8B%E4%B8%80%E4%BB%A3Web%E6%A1%86%E6%9E%B6/</guid>
      <pubDate>Thu, 04 Jul 2019 01:36:12 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;What-is-Koa&quot;&gt;&lt;a href=&quot;#What-is-Koa&quot; class=&quot;headerlink&quot; title=&quot;What is Koa?&quot;&gt;&lt;/a&gt;What is Koa?&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Koa&lt;/code&gt;  是Node.JS平台下的一款
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="What-is-Koa"><a href="#What-is-Koa" class="headerlink" title="What is Koa?"></a>What is Koa?</h2><p><code>Koa</code>  是Node.JS平台下的一款Web服务器框架，它由原<code>Express</code>团队开发，区别于<code>Express</code>大量使用<code>回调函数</code>的形式，<code>Koa</code>采用最新的<code>async/await</code>模式，使用异步函数的方式来处理HTTP请求</p><h2 id="Why-Koa？"><a href="#Why-Koa？" class="headerlink" title="Why Koa？"></a>Why Koa？</h2><p>相比于<code>Express</code>是一个高度集成化的Web框架，<code>Koa</code>显得更加的<strong>小而美</strong>，<br>它本身并不集成任何的中间件(包括路由)，但得益于它优秀的理念，以及便捷的模式，我们可以通过大量的第三方库对其功能进行扩充。</p><p>从业务上来说，使用<code>Koa</code>可以很容易地控制项目的规模。</p><p>从开发上来说，<code>Express</code>使用callback的方式处理异步，而在<code>Koa</code>中，<code>Koa1</code>采用generator，<code>Koa2</code>使用<code>async/await</code>的方式来处理异步流程控制。</p><p>例如使用callback的方式请求资源：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetchData(resourceID,method,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">process(data,<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">handle(result);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>换成generator的模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(resourceID);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = fetchData();</span><br><span class="line">data.next();</span><br><span class="line"><span class="keyword">var</span> result = process(data);</span><br><span class="line">result.next();</span><br><span class="line">handle(result);</span><br></pre></td></tr></table></figure><p>再使用async/await模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fetch(resourceID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">await</span> fetchData();</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> process(data);</span><br><span class="line">handle(result);</span><br></pre></td></tr></table></figure><p>可以看出，使用async/await的方式可以使得异步编程更加简洁易懂,而且最新的JS为我们提供了这样方便的模式，我们没有理由不使用更好且更新的东西。</p><h2 id="使用Koa2"><a href="#使用Koa2" class="headerlink" title="使用Koa2"></a>使用Koa2</h2><h3 id="使用Koa实现Hello-World"><a href="#使用Koa实现Hello-World" class="headerlink" title="使用Koa实现Hello World"></a>使用Koa实现Hello World</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">ctx.body = <span class="string">'Hello World!'</span>;</span><br><span class="line">next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">welcome</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line"><span class="keyword">await</span> next();</span><br><span class="line">ctx.body += <span class="string">'Welcome To Koa2'</span>;</span><br><span class="line">&#125;</span><br><span class="line">app.use(hello);</span><br><span class="line">app.use(welcome);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>与<code>Express</code>中不同，<code>Koa</code>将<code>request</code>和<code>response</code>集成到了<code>Context</code>中,也就是我们实现中间件函数中的<code>ctx</code>参数，可以通过<code>ctx.request</code>和<code>ctx.response</code>来对请求和响应进行操作。</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>目前<code>Koa</code>社区尚且比较小，但其量级够轻，并且更加先进，这应该是一个值得开拓的新技术，对于开发者自身来说，使用JS语言的新特性用也可以更加顺手</p>]]></content:encoded>
      
      <comments>https://www.hughex.com/2019/07/04/%E6%B5%85%E5%B0%9DKoa-%E2%80%94%E2%80%94-%E5%9F%BA%E4%BA%8ENode-JS%E7%9A%84%E4%B8%8B%E4%B8%80%E4%BB%A3Web%E6%A1%86%E6%9E%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[译]Docker化你的React应用</title>
      <link>https://www.hughex.com/2019/07/03/%E8%AF%91-Docker%E5%8C%96%E4%BD%A0%E7%9A%84React%E5%BA%94%E7%94%A8/</link>
      <guid>https://www.hughex.com/2019/07/03/%E8%AF%91-Docker%E5%8C%96%E4%BD%A0%E7%9A%84React%E5%BA%94%E7%94%A8/</guid>
      <pubDate>Wed, 03 Jul 2019 02:46:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;原文：&lt;a href=&quot;https://mherman.org/blog/dockerizing-a-react-app/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dockerizing a React App&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<p>原文：<a href="https://mherman.org/blog/dockerizing-a-react-app/" target="_blank" rel="noopener">Dockerizing a React App</a></p><p><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a>是一个可以帮助你加速开发和部署流程的容器工具。如果你使用微服务架构，Docker可以帮助你将各种小型的独立服务更方便地整合起来。并且因为你可以复制你本地的生产环境，它还可以帮你排除因为环境不同所带来的bug。</p><p>这个教程演示了怎样使用<a href="https://facebook.github.io/create-react-app/" target="_blank" rel="noopener">Create React App</a>将一个React应用Docker化。我们十分关注的点有-</p><ol><li>配置一个具有代码热重启功能的开发环境</li><li>使用多阶段构建配置一个准生产环境镜像[注：原文为production-ready image]</li></ol><p><img src="https://mherman.org/assets/img/blog/docker-logo.png" alt></p><p><em>更新:</em></p><ul><li>May 2019:<ul><li>更新到最新版本的Docker, Node, React, 和 Nginx.</li><li>增加了对各个Docker 命令和标记的解释.</li><li>根据读者评论和反馈添加了许多注释.</li></ul></li><li>Feb 2018:<ul><li>更新到最新版本的Node, React, 和 Nginx.</li><li>增加匿名卷.</li><li>增加了关于配置 Nginx 来配合使用 React Router 的详细内容.</li><li>增加了使用多阶段构建生产环境的部分.</li></ul></li></ul><p><em>本文使用的软件版本:</em></p><ul><li>Docker v18.09.2</li><li>Create React App v3.0.1</li><li>Node v12.2.0</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#项目安装">项目安装</a></li><li><a href="#Docker">Docker</a></li><li><a href="#Docker-Machine">Docker Machine</a></li><li><a href="#生产环境">生产环境</a></li><li><a href="#React-Router-和-Nginx">React Router 和 Nginx</a></li><li><a href="#接下来">接下来</a></li></ul><h2 id="项目安装"><a href="#项目安装" class="headerlink" title="项目安装"></a>项目安装</h2><p>全局安装 <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g create-react-app@3.0.1</span><br></pre></td></tr></table></figure><p>生成一个新应用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ create-react-app sample</span><br><span class="line">$ cd sample</span><br></pre></td></tr></table></figure><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>在项目的根目录下添加一个 <em>Dockerfile</em> :</p><pre><code># 基础镜像FROM node:12.2.0-alpine# 设置工作目录WORKDIR /app# 把 `/app/node_modules/.bin` 加到$PATH中ENV PATH /app/node_modules/.bin:$PATH# 安装并缓存应用依赖COPY package.json /app/package.jsonRUN npm install --silentRUN npm install react-scripts@3.0.1 -g --silent# 启动应用CMD [&quot;npm&quot;, &quot;start&quot;]</code></pre><blockquote><p>如果你需要的话，你可以通过<code>--silent</code>选项将NPM的输出过滤掉。通常不推荐这样，因为它会把错误输出也给屏蔽掉。随时注意这个可以避免在调试时浪费太多时间</p></blockquote><p>新建一个<em>.dockerignore</em>:</p><pre><code>node_modules</code></pre><p>这将加速Docker构建过程，因为我们的本地依赖项将不会发送到Docker守护程序。</p><p>构建并标记这个Docker镜像:</p><pre><code>$ docker build -t sample:dev .</code></pre><p>构建完成之后启动这个容器:</p><pre><code>$ docker run -v ${PWD}:/app -v /app/node_modules -p 3001:3000 --rm sample:dev</code></pre><blockquote><p>如果你得到一个<code>&quot;ENOENT: no such file or directory, open &#39;/app/package.json&quot;.</code>这样的错误, 你可能需要添加一个额外的卷: <code>-v /app/package.json</code>.</p></blockquote><p>这里发生了什么?</p><ol><li><a href="https://docs.docker.com/engine/reference/commandline/run/" target="_blank" rel="noopener">docker run</a> 的命令用我们刚刚创建的Docker镜像创建了一个容器实例,然后将它跑起来.</li><li><p><code>-v ${PWD}:/app</code> 将代码装载至容器中的 “/app”目录.</p><blockquote><p><code>{PWD}</code>在Windows下可能没用. 可以在<a href="https://stackoverflow.com/questions/41485217/mount-current-directory-as-a-volume-in-docker-on-windows-10" target="_blank" rel="noopener">这里</a>查看Stack Overflow上的具体问题.</p></blockquote></li><li><p>为了使用容器中的“node_modules”目录, 我们再配置一个卷: <code>-v /app/node_modules</code>. 你现在就可以删除本地的 “node_modules” 目录了.</p></li><li><p><code>-p 3001:3000</code> 将3000端口暴露给同一个网络下的Docker容器 (用作容器间通信) 并且将3001端口暴露给主机.</p><blockquote><p>在Stack Overflow上查看<a href="https://stackoverflow.com/questions/22111060/what-is-the-difference-between-expose-and-publish-in-docker" target="_blank" rel="noopener">该问题</a>以获取更多信息。</p></blockquote></li><li><p>最后, <code>--rm</code> 在容器退出后<a href="https://docs.docker.com/engine/reference/run/#clean-up---rm" target="_blank" rel="noopener">移除</a>这个容器和卷.</p></li></ol><p>打开浏览器访问<a href="http://localhost:3001/" target="_blank" rel="noopener">http://localhost:3001/</a> 就可以访问这个应用了. 尝试在编辑器中对 <code>App</code> 组建上进行修改， 就能发现应用已经热重启了。在完成后关闭服务器。</p><blockquote><p>你加了<code>-it</code>选项时发生了什么?</p><pre><code>$ docker run -it -v ${PWD}:/app -v /app/node_modules -p 3001:3000 --rm sample:dev</code></pre><p>按照你的理解自己验证一下.</p></blockquote><p>希望使用 <a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">Docker Compose</a>吗? 在项目根目录新增一个 <em>docker-compose.yml</em> 文件:</p><pre><code>version: &apos;3.7&apos;services:  sample:    container_name: sample    build:      context: .      dockerfile: Dockerfile    volumes:      - &apos;.:/app&apos;      - &apos;/app/node_modules&apos;    ports:      - &apos;3001:3000&apos;    environment:      - NODE_ENV=development</code></pre><p>注意卷的配置， 如果没有这个 <a href="https://success.docker.com/article/Different_Types_of_Volumes" target="_blank" rel="noopener">匿名</a> 卷 (<code>&#39;/app/node_modules&#39;</code>), _node_modules_ 这个目录在运行时就会被你项目中的那个目录覆盖。换句话说, 会发生下面的事:</p><ul><li><em>Build</em> - <code>node_modules</code>这个目录在镜像中被创建。</li><li><em>Run</em> - 当前的目录被装载至容器中, 覆盖掉我们在Build时创建的<code>node_modules</code>目录.</li></ul><p>构建镜像并运行容器:</p><pre><code>$ docker-compose up -d --build</code></pre><p>再次确认应用运行成功并且可以热重启，然后在继续之前停止容器:</p><pre><code>$ docker-compose stop</code></pre><blockquote><p><em>Windows用户</em>: 在配置卷时遇到问题的话，可以查看下列资源:</p><ol><li><a href="https://rominirani.com/docker-on-windows-mounting-host-directories-d96f3f056a2c" target="_blank" rel="noopener">Docker on Windows–Mounting Host Directories</a></li><li><a href="https://blogs.msdn.microsoft.com/stevelasker/2016/06/14/configuring-docker-for-windows-volumes/" target="_blank" rel="noopener">Configuring Docker for Windows Shared Drives</a></li></ol><p>你也可以在Docker Compose的evironment部分中添加 <code>COMPOSE_CONVERT_WINDOWS_PATHS=1</code>。查看 <a href="https://docs.docker.com/compose/env-file/" target="_blank" rel="noopener">Declare default environment variables in file</a> 教程以获取更多信息.</p></blockquote><h2 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h2><p>如果要在 <a href="https://docs.docker.com/machine/" target="_blank" rel="noopener">Docker Machine</a> 和 <a href="https://docs.docker.com/machine/get-started/" target="_blank" rel="noopener">VirtualBox</a>上搭建这个热重启服务，你需要通过<a href="https://github.com/paulmillr/chokidar" target="_blank" rel="noopener">chokidar</a>来<a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#troubleshooting" target="_blank" rel="noopener">启用</a>一个轮询机制  (封装了 <code>fs.watch</code>, <code>fs.watchFile</code>, 和 <code>fsevents</code>).</p><p>创建一个新Machine:</p><pre><code>$ docker-machine create -d virtualbox sample$ docker-machine env sample$ eval $(docker-machine env sample)</code></pre><p>拿到IP:</p><pre><code>$ docker-machine ip sample</code></pre><p>然后构建镜像并运行容器:</p><pre><code>$ docker build -t sample:dev .$ docker run -v ${PWD}:/app -v /app/node_modules -p 3001:3000 --rm sample:dev</code></pre><p>访问<a href="http://DOCKER_MACHINE_IP:3001/" target="_blank" rel="noopener">http://DOCKER_MACHINE_IP:3001/</a>再测试一遍应用， (注意将 <code>DOCKER_MACHINE_IP</code> 替换成你真正的Docker Machine的IP). 并且发现热重启 _不再_ 工作. 用Docker Compose也一样。</p><p>要重新启用热重启, 得加一个环境变量: <code>CHOKIDAR_USEPOLLING=true</code>.</p><pre><code>$ docker run -v ${PWD}:/app -v /app/node_modules -p 3001:3000 -e CHOKIDAR_USEPOLLING=true --rm sample:dev</code></pre><p>再测试一次. 确认热重启又工作了.</p><p>更新后的 <em>docker-compose.yml</em> 文件:</p><pre><code>version: &apos;3.7&apos;services:  sample:    container_name: sample    build:      context: .      dockerfile: Dockerfile    volumes:      - &apos;.:/app&apos;      - &apos;/app/node_modules&apos;    ports:      - &apos;3001:3000&apos;    environment:      - NODE_ENV=development      - CHOKIDAR_USEPOLLING=true</code></pre><h2 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h2><p>创建一个单独的Dockerfile命名为 <em>Dockerfile-prod</em>:</p><pre><code># build environmentFROM node:12.2.0-alpine as buildWORKDIR /appENV PATH /app/node_modules/.bin:$PATHCOPY package.json /app/package.jsonRUN npm install --silentRUN npm install react-scripts@3.0.1 -g --silentCOPY . /appRUN npm run build# production environmentFROM nginx:1.16.0-alpineCOPY --from=build /app/build /usr/share/nginx/htmlEXPOSE 80CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code></pre><p>这里我们利用了 <a href="https://docs.docker.com/engine/userguide/eng-image/multistage-build/" target="_blank" rel="noopener">多阶段构建</a> 模式来创建一个临时镜像，用来构建已经为生产环境准备的React static文件，然后复制到生产镜像中. 然后这个临时构建镜像和原始文件和目录一起被丢弃，就生成了一个精简后的，生产环境镜像。</p><blockquote><p>通过这篇博客可以更多的了解多阶段构建 <a href="https://blog.alexellis.io/mutli-stage-docker-builds/" target="_blank" rel="noopener">Builder pattern vs. Multi-stage builds in Docker</a>.</p></blockquote><p>使用生产环境Dockerfile, 构建并标记镜像:</p><pre><code>$ docker build -f Dockerfile-prod -t sample:prod .</code></pre><p>运行容器:</p><pre><code>$ docker run -it -p 80:80 --rm sample:prod</code></pre><p>如果你还在用同一个Docker Machine的话, 使用浏览器访问 <a href="http://DOCKER_MACHINE_IP" target="_blank" rel="noopener">http://DOCKER_MACHINE_IP</a>。</p><p>使用一个新的Docker Compose文件命名为 <em>docker-compose-prod.yml</em>:</p><pre><code>version: &apos;3.7&apos;services:  sample-prod:    container_name: sample-prod    build:      context: .      dockerfile: Dockerfile-prod    ports:      - &apos;80:80&apos;</code></pre><p>运行容器:</p><pre><code>$ docker-compose -f docker-compose-prod.yml up -d --build</code></pre><p>再用浏览器测试一次. 然后就完成了, 然后销毁Docker Machine:</p><pre><code>$ eval $(docker-machine env -u)$ docker-machine rm sample</code></pre><h2 id="React-Router-和-Nginx"><a href="#React-Router-和-Nginx" class="headerlink" title="React Router 和 Nginx"></a>React Router 和 Nginx</h2><p>如果你使用 <a href="https://reacttraining.com/react-router/" target="_blank" rel="noopener">React Router</a>, 那么你需要再构建时修改默认的nginx配置:</p><pre><code>RUN rm /etc/nginx/conf.d/default.confCOPY nginx/nginx.conf /etc/nginx/conf.d</code></pre><p>把这个修改加入到 <em>Dockerfile-prod</em>:</p><pre><code># build environmentFROM node:12.2.0-alpine as buildWORKDIR /appENV PATH /app/node_modules/.bin:$PATHCOPY package.json /app/package.jsonRUN npm install --silentRUN npm install react-scripts@3.0.1 -g --silentCOPY . /appRUN npm run build# production environmentFROM nginx:1.16.0-alpineCOPY --from=build /app/build /usr/share/nginx/htmlRUN rm /etc/nginx/conf.d/default.confCOPY nginx/nginx.conf /etc/nginx/conf.dEXPOSE 80CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code></pre><p>创建以下的目录并且添加 <em>nginx.conf</em> 这个文件:</p><pre><code>└── nginx    └── nginx.conf</code></pre><p><em>nginx.conf</em>:</p><pre><code>server {  listen 80;  location / {    root   /usr/share/nginx/html;    index  index.html index.htm;    try_files $uri $uri/ /index.html;  }  error_page   500 502 503 504  /50x.html;  location = /50x.html {    root   /usr/share/nginx/html;  }}</code></pre><h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><p>现在, 你就可以将React添加到开发和生产环境的更大的Docker驱动的项目中使用了. 如果你想学习使用React和Docker来构建和测试微服务, 请访问 <a href="https://testdriven.io/" target="_blank" rel="noopener">Microservices with Docker, Flask, and React</a> 教程.</p>]]></content:encoded>
      
      <comments>https://www.hughex.com/2019/07/03/%E8%AF%91-Docker%E5%8C%96%E4%BD%A0%E7%9A%84React%E5%BA%94%E7%94%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>在ESXi6.5上安装macOS 10.13.6虚拟系统</title>
      <link>https://www.hughex.com/2018/07/30/%E5%9C%A8ESXi6.5%E4%B8%8A%E5%AE%89%E8%A3%85macOS%2010.13.6%E8%99%9A%E6%8B%9F%E7%B3%BB%E7%BB%9F/</link>
      <guid>https://www.hughex.com/2018/07/30/%E5%9C%A8ESXi6.5%E4%B8%8A%E5%AE%89%E8%A3%85macOS%2010.13.6%E8%99%9A%E6%8B%9F%E7%B3%BB%E7%BB%9F/</guid>
      <pubDate>Mon, 30 Jul 2018 10:19:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;曾经在Windows的VMWare Workstations上安装过&lt;code&gt;OSX 10.11 EI Capitan&lt;/code&gt;系统, 是依赖 &lt;code&gt;Unlocker&lt;/code&gt;插件开启软件的OSX系统支持。&lt;/p&gt;
&lt;p&gt;如今在ESXi上安装macOS  1
        
      
      </description>
      
      <content:encoded><![CDATA[<p>曾经在Windows的VMWare Workstations上安装过<code>OSX 10.11 EI Capitan</code>系统, 是依赖 <code>Unlocker</code>插件开启软件的OSX系统支持。</p><p>如今在ESXi上安装macOS  10.13.6，同样使用<code>Unlocker</code>却行不通了。于是我在Mac 的VMWare Fusion上尝试了安装macOS 10.13.6，可以完美运行，然后将安装好的虚拟机上传至ESXi却无法引导。</p><p>究其原因，答案竟是—<strong>APFS</strong>！在win下和ESXi下的VMWare并不支持APFS文件系统。</p><p>于是我尝试了先安装最后一个支持<code>HFS+</code>的系统：<strong>macOS 10.12 Sierra</strong>，安装时格式化硬盘为<code>HFS+</code>，然后安装运行，完美！</p><p>然后从<code>MAS</code>中下载<code>macOS High Sierra</code>，下载完成后不直接运行安装程序，而是打开<code>终端</code>，键入以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /Applications/Install\ macOS\ High\ Sierra.app/Contents/Resources/startosinstall --converttoapfs NO --agreetolicense --nointeraction</span><br></pre></td></tr></table></figure></p><p>然后升级就开始啦</p><p>等待安装完成</p>]]></content:encoded>
      
      <comments>https://www.hughex.com/2018/07/30/%E5%9C%A8ESXi6.5%E4%B8%8A%E5%AE%89%E8%A3%85macOS%2010.13.6%E8%99%9A%E6%8B%9F%E7%B3%BB%E7%BB%9F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用Laravel + Infyom Laravel Generator + MySQL开发RESTful规范的移动应用API</title>
      <link>https://www.hughex.com/2018/02/11/%E4%BD%BF%E7%94%A8Laravel-Infyom-Laravel-Generator-MySQL%E5%BC%80%E5%8F%91RESTful%E8%A7%84%E8%8C%83%E7%9A%84%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8API/</link>
      <guid>https://www.hughex.com/2018/02/11/%E4%BD%BF%E7%94%A8Laravel-Infyom-Laravel-Generator-MySQL%E5%BC%80%E5%8F%91RESTful%E8%A7%84%E8%8C%83%E7%9A%84%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8API/</guid>
      <pubDate>Sun, 11 Feb 2018 07:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;命名&quot;&gt;&lt;a href=&quot;#命名&quot; class=&quot;headerlink&quot; title=&quot;命名&quot;&gt;&lt;/a&gt;命名&lt;/h2&gt;&lt;h3 id=&quot;驼峰规则&quot;&gt;&lt;a href=&quot;#驼峰规则&quot; class=&quot;headerlink&quot; title=&quot;驼峰规则&quot;&gt;&lt;/a&gt;驼峰规则&lt;/h
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="驼峰规则"><a href="#驼峰规则" class="headerlink" title="驼峰规则"></a>驼峰规则</h3><p>由于涉及到多种格式规范的命名，我们约定在<code>PHP</code>代码中:<code>类</code>名及<code>静态方法</code>的命名使用<strong><em>大驼峰规则</em></strong>，即<code>AaaBbbCcc</code>格式，而<code>变量</code>和<code>实例方法</code>的命名使用使用<strong><em>小驼峰规则</em></strong>，即<code>aaaBbbCcc</code>格式。</p><h3 id="下划线命名"><a href="#下划线命名" class="headerlink" title="下划线命名"></a>下划线命名</h3><p>除PHP程序代码使用<code>驼峰规则</code>，我们在下述几种情况下使用<code>下划线命名</code>，即单词均为<strong><em>纯小写</em></strong>，单词之间使用<strong><em>下划线</em></strong>分隔(<code>aaa_bbb_ccc</code>)。</p><p>使用下划线命名的情况包括：</p><ol><li>数据库表名</li><li>数据库字段</li><li>RESTful API返回值<code>key</code>名</li><li>RESTful API请求参数名</li></ol><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="安装composer"><a href="#安装composer" class="headerlink" title="安装composer"></a>安装composer</h3><p><a href="https://getcomposer.org/download/" target="_blank" rel="noopener">官网</a><br>composer用来做包管理器</p><h3 id="安装Laravel"><a href="#安装Laravel" class="headerlink" title="安装Laravel"></a>安装Laravel</h3><p>下载安装程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer global require &quot;laravel/installer&quot;</span><br></pre></td></tr></table></figure><p>确保 $HOME/.composer/vendor/bin 目录（或你的操作系统的等效目录）已经放在你的环境变量 $PATH 中，以便系统可以找到 laravel 的可执行文件。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><h4 id="通过Laravel"><a href="#通过Laravel" class="headerlink" title="通过Laravel"></a>通过Laravel</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">laravel new 你的项目</span><br></pre></td></tr></table></figure><p>将自动帮你创建目录，以及安装<code>Laravel</code>的依赖。</p><h4 id="通过composer"><a href="#通过composer" class="headerlink" title="通过composer"></a>通过composer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist laravel/laravel 你的项目</span><br></pre></td></tr></table></figure><h3 id="Infyom-Laravel-Generator"><a href="#Infyom-Laravel-Generator" class="headerlink" title="Infyom Laravel Generator"></a>Infyom Laravel Generator</h3><p>默认到此步骤，已完成数据库连接的配置。</p><p>此处可以通过<code>Infyom Laravel Generator</code>来生成<code>Model</code>、<code>Controller</code>、<code>API</code>等模板代码</p><h4 id="生成Model"><a href="#生成Model" class="headerlink" title="生成Model"></a>生成Model</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan infyom:model 模型名称 --fromTable --tableName=数据库表名</span><br></pre></td></tr></table></figure><h4 id="生成API"><a href="#生成API" class="headerlink" title="生成API"></a>生成API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan infyom:api 模型名称 --fromTable --tableName=数据库表名</span><br></pre></td></tr></table></figure><h4 id="生成脚手架"><a href="#生成脚手架" class="headerlink" title="生成脚手架"></a>生成脚手架</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan infyom:scaffold 模型名称 --fromTable --tableName=数据库表名</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.hughex.com/2018/02/11/%E4%BD%BF%E7%94%A8Laravel-Infyom-Laravel-Generator-MySQL%E5%BC%80%E5%8F%91RESTful%E8%A7%84%E8%8C%83%E7%9A%84%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8API/#disqus_thread</comments>
    </item>
    
    <item>
      <title>iOS 3D Touch Shortcut 开发</title>
      <link>https://www.hughex.com/2017/09/18/iOS-3D-Touch-Shortcut-%E5%BC%80%E5%8F%91/</link>
      <guid>https://www.hughex.com/2017/09/18/iOS-3D-Touch-Shortcut-%E5%BC%80%E5%8F%91/</guid>
      <pubDate>Mon, 18 Sep 2017 09:12:42 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;ShortcutItem&quot;&gt;&lt;a href=&quot;#ShortcutItem&quot; class=&quot;headerlink&quot; title=&quot;ShortcutItem&quot;&gt;&lt;/a&gt;ShortcutItem&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ShortcutItem&lt;/code&gt;是苹果在&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="ShortcutItem"><a href="#ShortcutItem" class="headerlink" title="ShortcutItem"></a>ShortcutItem</h1><p><code>ShortcutItem</code>是苹果在<code>iOS9</code>/<code>iPhone6s</code>发布时添加的新功能，主要利用了新iPhone的3D Touch特性，用户在重压APP图标时，可以弹出设定好的应用程序快捷方式</p><h1 id="配置ShortcutItem"><a href="#配置ShortcutItem" class="headerlink" title="配置ShortcutItem"></a>配置ShortcutItem</h1><p>配置<code>ShortcutItem</code>有两种方式：通过工程<code>info.plist</code>配置文件进行添加和在APP的<code>UIApplication</code>对象中<code>shortcutItems</code>属性中修改。笔者下面将对其逐一介绍。</p><h2 id="info-plist配置"><a href="#info-plist配置" class="headerlink" title="info.plist配置"></a>info.plist配置</h2><p>在<code>info.plist</code>中添加如下的配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>UIApplicationShortcutItems<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  项目Bundle中的Image Name名称，对应Shortcut右侧的图标，注意，建议使用单色、透明的png --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>UIApplicationShortcutItemIconFile<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>open-favorites<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 必须指定，Shortcut的标题，支持i18n --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>UIApplicationShortcutItemTitle<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>Favorites<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 必须指定，用于区别ShortcutItem --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>UIApplicationShortcutItemType<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.mycompany.myapp.openfavorites<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- userinfo 可以带相应的自定义信息，以字典形式传入 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>UIApplicationShortcutItemUserInfo<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>key1<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>value1<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Shortcut的图标，如果没有设置IconFile可以选择系统预设的图标，种类还算比较多</span></span><br><span class="line"><span class="comment">            具体参见 https://developer.apple.com/documentation/uikit/uiapplicationshortcuticontype --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>UIApplicationShortcutItemIconType<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>UIApplicationShortcutIconTypeCompose<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>UIApplicationShortcutItemTitle<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>New Message<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 可以指定Shortcut的子标题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>UIApplicationShortcutItemSubtitle<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>You Can Insert New Message<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>UIApplicationShortcutItemType<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.mycompany.myapp.newmessage<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>UIApplicationShortcutItemUserInfo<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>key2<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>value2<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过上面的配置，一个程序中固定的<code>Shortcut</code>就可以配置完成了。</p><h2 id="通过UIApplication配置"><a href="#通过UIApplication配置" class="headerlink" title="通过UIApplication配置"></a>通过UIApplication配置</h2><p>一般情况下，我们会在<code>AppDelegate</code>下，<code>application(_ application: didFinishLaunchingWithOptions:)</code>方法中添加</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">application.shortcutItems = []</span><br><span class="line"></span><br><span class="line">application.shortcutItems = [<span class="type">UIApplicationShortcutItem</span>(type: &lt;#<span class="type">T</span>##<span class="type">String</span>#&gt;, localizedTitle: &lt;#<span class="type">T</span>##<span class="type">String</span>#&gt;, localizedSubtitle: &lt;#<span class="type">T</span>##<span class="type">String?</span>#&gt;, icon: &lt;#<span class="type">T</span>##<span class="type">UIApplicationShortcutIcon?</span>#&gt;, userInfo: &lt;#<span class="type">T</span>##[<span class="type">AnyHashable</span> : <span class="type">Any</span>]?#&gt;)]</span><br><span class="line"></span><br><span class="line">application.shortcutItems?.append(<span class="type">UIApplicationShortcutItem</span>(type: &lt;#<span class="type">T</span>##<span class="type">String</span>#&gt;, localizedTitle: &lt;#<span class="type">T</span>##<span class="type">String</span>#&gt;, localizedSubtitle: &lt;#<span class="type">T</span>##<span class="type">String?</span>#&gt;, icon: &lt;#<span class="type">T</span>##<span class="type">UIApplicationShortcutIcon?</span>#&gt;, userInfo: &lt;#<span class="type">T</span>##[<span class="type">AnyHashable</span> : <span class="type">Any</span>]?#&gt;))</span><br></pre></td></tr></table></figure><p>如上这样的代码即可添加。</p><p>这样做看起来比在配置文件中进行添加要快和简单许多，而且使用代码管理也显得清晰明了，但这样的坏处就是应用程序在安装或更新后，新的ShortcutItem需要程序先启动一次，并且执行了配置的代码后才能被添加到程序中，而使用配置文件则不需要，它在安装时就已经写入了配置。</p><p>而是用代码添加的好处是可以根据应用程序的不同状态来更改不同的<code>Shortcut</code>设置，所以实际使用中，这两种方法可能会搭配使用</p><h1 id="响应ShortcutItem配置"><a href="#响应ShortcutItem配置" class="headerlink" title="响应ShortcutItem配置"></a>响应ShortcutItem配置</h1><p>上面我们为App添加了ShortcutItem配置，剩下的我们需要做的就是，根据不同的ShortcutItem执行不同的逻辑，我们只需要在<code>AppDelegate</code>中实现<code>application(_ application:performActionFor:completionHandler:</code>方法，在这个方法中去获取<code>shortcutItem</code>对象并执行相应逻辑即可。</p>]]></content:encoded>
      
      <comments>https://www.hughex.com/2017/09/18/iOS-3D-Touch-Shortcut-%E5%BC%80%E5%8F%91/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Custom Keyboard Extension 的屁事博 -- 在Container App 中植入键盘(二)</title>
      <link>https://www.hughex.com/2017/07/05/Custom-Keyboard-Extension-%E7%9A%84%E5%B1%81%E4%BA%8B%E5%8D%9A-%E5%9C%A8Container-App-%E4%B8%AD%E6%A4%8D%E5%85%A5%E9%94%AE%E7%9B%98-%E4%BA%8C/</link>
      <guid>https://www.hughex.com/2017/07/05/Custom-Keyboard-Extension-%E7%9A%84%E5%B1%81%E4%BA%8B%E5%8D%9A-%E5%9C%A8Container-App-%E4%B8%AD%E6%A4%8D%E5%85%A5%E9%94%AE%E7%9B%98-%E4%BA%8C/</guid>
      <pubDate>Wed, 05 Jul 2017 02:14:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;转&quot;&gt;&lt;a href=&quot;#转&quot; class=&quot;headerlink&quot; title=&quot;转&quot;&gt;&lt;/a&gt;转&lt;/h1&gt;&lt;p&gt;开始着手现有输入法植入工作，亟待解决的问题有下面几个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统调用输入法时&lt;strong&gt;KeyboardViewContr
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="转"><a href="#转" class="headerlink" title="转"></a>转</h1><p>开始着手现有输入法植入工作，亟待解决的问题有下面几个：</p><ol><li>系统调用输入法时<strong>KeyboardViewController</strong>如何加载</li><li>能否(如何)将<strong>KeyboardViewController</strong>的视图加载到应用程序的视图控制器</li><li><strong>Keyboard</strong>如何(是否需要)与输入框进行关联</li></ol><p>下面来一一解决：</p><h2 id="系统调用键盘"><a href="#系统调用键盘" class="headerlink" title="系统调用键盘"></a>系统调用键盘</h2><p>上一张经典图<br><img src="https://ws1.sinaimg.cn/large/6b7d44cfgy1fh7yo4r6z6j21170s9q3z.jpg" alt></p><p>关于<code>Extension</code>、<code>Container App</code>、<code>Host App</code>这三者的关系这里不再赘述，网上很多资料。这里体现了一件事情就是：<strong>系统在调用键盘时，Keyboard是没有加载在应用程序keyWindow中的，</strong>而是在一个新的名叫<code>UIRemoteKeyboardWindow</code>的窗口中</p><p><img src="https://ws1.sinaimg.cn/large/6b7d44cfgy1fh7zfyf2lsj20qx0ifdi8.jpg" alt="系统日语输入法在App中加载"></p><h2 id="应用程序视图中加载键盘"><a href="#应用程序视图中加载键盘" class="headerlink" title="应用程序视图中加载键盘"></a>应用程序视图中加载键盘</h2><p>在以前的项目中，当我们希望系统弹出键盘时一般使用<code>textField.becomeFirstResponder()</code>这样的方法，让输入框成为第一响应者来实现。现在我们需要的是指定一个我们项目中已经实现过的<code>KeyboardViewController</code>来弹出，而不是通过系统调用键盘，然后让用户切换过去。</p><p>调查过后锁定了几个东西：<code>UITextField.inputView</code>、<code>UIResponder.inputViewController</code>、<br>实验发现，不论是设置<code>inputView</code>为<code>KeyboardViewController</code>的<code>view</code>或者是重载<code>UITextField</code>的<code>inputViewController</code>设置为<code>KeyboardViewController</code>都可以实现在<code>UIRemoteKeyboardWindow</code>窗口中调起该键盘。</p><p>但这样调起的键盘无法在画面中获得，也无法设置画面约束等，仅仅是一个调起指定实现的键盘的方法，局限性太大。</p><p>既然<code>KeyboardViewController</code>的父类<code>UIInputViewController</code>是基于<code>UIViewController</code>的，那么我们能不能直接将它作为<strong>子VC</strong>并将视图加入应用程序视图中呢?</p><p>好像没啥问题</p><p>最简单实现<code>childViewController</code>的方法就是直接使用<code>storyboard</code>中的<code>Container View</code>。拖上容器，设置约束，将子VC类型设置为我们的<code>KeyboardViewController</code>，直接运行，键盘就躺在画面中等着我们了。</p><h2 id="关联输入框"><a href="#关联输入框" class="headerlink" title="关联输入框"></a>关联输入框</h2><p>这时候，点击输入框，诶？</p><p><img src="http://ww1.sinaimg.cn/large/6b7d44cfgy1fh88zea8k3j20r41h8jup.jpg" alt></p><p>怎么又弹出一个新键盘出来了，先不管，点击收起弹出来的键盘，在我们的子VC的键盘上操作，诶？好像可以直接输入到输入框上？！似乎：<strong>加载在视图中的UIInputView</strong>，输出文字会自动输入到当前的<code>FirstResponder</code>中，而不用做其他关联</p><h1 id="合"><a href="#合" class="headerlink" title="合"></a>合</h1><p>这似乎是一个比较好的实现，不过我们还得解决一下输入框获得焦点时系统弹出键盘的问题。这时，我们的<code>inputView</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textField.inputView = <span class="type">UIView</span>()</span><br></pre></td></tr></table></figure><p>或者直接重载<code>inputViewController</code>、<code>inputView</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITextField</span> </span>&#123;</span><br><span class="line"><span class="comment">//重载应用中所有textField的inputViewController</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">override</span> <span class="keyword">var</span> inputViewController: <span class="type">UIInputViewController?</span>&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">UIInputViewController</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTextField</span>: <span class="title">UITextField</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> emptyInputView = <span class="type">UIView</span>()</span><br><span class="line">    <span class="comment">//重载inputView</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> inputView: <span class="type">UIView?</span> &#123;</span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> emptyInputView</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/6b7d44cfgy1fh8azll0zij20r41h840n.jpg" alt></p><p>完美√</p>]]></content:encoded>
      
      <comments>https://www.hughex.com/2017/07/05/Custom-Keyboard-Extension-%E7%9A%84%E5%B1%81%E4%BA%8B%E5%8D%9A-%E5%9C%A8Container-App-%E4%B8%AD%E6%A4%8D%E5%85%A5%E9%94%AE%E7%9B%98-%E4%BA%8C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Custom Keyboard Extension 的屁事博 -- 在Container App 中植入键盘（一）</title>
      <link>https://www.hughex.com/2017/06/03/Custom-Keyboard-Extension-%E7%9A%84%E5%B1%81%E4%BA%8B%E5%8D%9A-%E5%9C%A8Container-App-%E4%B8%AD%E6%A4%8D%E5%85%A5%E9%94%AE%E7%9B%98%EF%BC%88%E4%B8%80%EF%BC%89/</link>
      <guid>https://www.hughex.com/2017/06/03/Custom-Keyboard-Extension-%E7%9A%84%E5%B1%81%E4%BA%8B%E5%8D%9A-%E5%9C%A8Container-App-%E4%B8%AD%E6%A4%8D%E5%85%A5%E9%94%AE%E7%9B%98%EF%BC%88%E4%B8%80%EF%BC%89/</guid>
      <pubDate>Sat, 03 Jun 2017 08:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;起&quot;&gt;&lt;a href=&quot;#起&quot; class=&quot;headerlink&quot; title=&quot;起&quot;&gt;&lt;/a&gt;起&lt;/h1&gt;&lt;p&gt;亲爱的甲方在键盘的&lt;code&gt;Container App&lt;/code&gt;里面做一个&lt;strong&gt;「学习模块」&lt;/strong&gt;，想要就是在&lt;code
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="起"><a href="#起" class="headerlink" title="起"></a>起</h1><p>亲爱的甲方在键盘的<code>Container App</code>里面做一个<strong>「学习模块」</strong>，想要就是在<code>Container App</code>里面让用户学习使用键盘的模式。这是基于我们keyboard Extension本身功能已经健全(绝对没有一丝的设计不合理，也不是因为输入法学习成本高，只是为某些LowB用户提供的智商扶贫计划😉)。</p><p>基于这样的需求，我们不能简单给用户一个输入框，让用户自己切换输入法在那练练练，而是把键盘直接植入到应用程序画面中，用户进入画面中，我们的键盘就已经在画面中stand by了。</p><h1 id="承"><a href="#承" class="headerlink" title="承"></a>承</h1><p>项目开始调查，我开始了植入方案的研究。项目会议时，我提出了几个方案： </p><ol><li>将现有的输入法代码<code>加入</code>容器App的<strong>编译</strong>，并在容器中以某种方式实现<strong>加载</strong>该输入法，并实现<strong>联动</strong>输入框</li><li>在容器App中<strong>重新实现(Copy)</strong>一套输入法逻辑，就像普通的自定义轮子一样加载View，并不与输入法的一套规则产生联系</li><li>告诉客户：这个方案太贵了，原因如下。。。</li></ol><h2 id="方案选择："><a href="#方案选择：" class="headerlink" title="方案选择："></a>方案选择：</h2><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p>当然是最好的方案，优点是<strong>完全重用</strong>现有输入法逻辑，与现有产品在功能式样上保持高度一致，将来需求的变更可以同步反映，代码量少，大量的代码规模都可以用于业务逻辑✌️。但缺点也很明显：<strong>可行性未知</strong>，<strong>国内相关经验少</strong>，相关资料几乎为0，仅在<a href="https://stackoverflow.com/" target="_blank" rel="noopener">栈溢出论坛</a>上有少量的有用信息。</p><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>一个泥瓦匠刚刚学会砌墙，就希望拿手上这点手艺，修建高楼大厦，用这种无限使用于未来的方法，置换体内星辰河流。这个方法无疑是最体力活、最屌丝的方法：大量重复逻辑的编写，工匠之心囿于界面与接口；无法反映将来输入法需求变更的修改；随着项目规模扩大，它将难以维护。但就目前来说，它具有高可行性，能实现现阶段的客户需求。</p><h3 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h3><p>却下，客户说：有的是钱。</p><p>讨论的结果是，先前期调查<strong>方案1</strong>的可行性，并尝试实现植入，如果可行，便上马，如若不行或短时间内不行，还有<strong>方案2</strong>作为备胎方案，暂时放下你的破情怀，先面向需求编程再说。</p>]]></content:encoded>
      
      <comments>https://www.hughex.com/2017/06/03/Custom-Keyboard-Extension-%E7%9A%84%E5%B1%81%E4%BA%8B%E5%8D%9A-%E5%9C%A8Container-App-%E4%B8%AD%E6%A4%8D%E5%85%A5%E9%94%AE%E7%9B%98%EF%BC%88%E4%B8%80%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Swift进阶--结构体与类（一）</title>
      <link>https://www.hughex.com/2017/01/19/Swift%E8%BF%9B%E9%98%B6-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB/</link>
      <guid>https://www.hughex.com/2017/01/19/Swift%E8%BF%9B%E9%98%B6-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB/</guid>
      <pubDate>Thu, 19 Jan 2017 10:31:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;引用类型-VS-值类型&quot;&gt;&lt;a href=&quot;#引用类型-VS-值类型&quot; class=&quot;headerlink&quot; title=&quot;引用类型 VS 值类型&quot;&gt;&lt;/a&gt;引用类型 VS 值类型&lt;/h1&gt;&lt;p&gt;Swift中提供的数据类型分为&lt;strong&gt;引用类型（refere
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="引用类型-VS-值类型"><a href="#引用类型-VS-值类型" class="headerlink" title="引用类型 VS 值类型"></a>引用类型 VS 值类型</h1><p>Swift中提供的数据类型分为<strong>引用类型（reference type）</strong>和<strong>值类型（value type）</strong>两类，其中”类”属于引用类型，而”Int”、”struct”等类型属于值类型。</p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>值类型指的是在<code>赋值</code>、<code>传递参数</code>、<code>初始化</code>过程中，会创建一个新的实例的类型，在使用值类型数据的时候，我们往往需要对某些值进行计算操作，又需要保证这些值的不变性。比如下面的例子:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="type">Person</span>(age:<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = person1</span><br><span class="line">person2.age += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">person1.age <span class="comment">//1</span></span><br><span class="line">person2.age <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们有一个<code>Person</code>结构体。person1是1岁，person2比person1大一岁，我们将person1赋值给person2，并且对person2的age做加1操作,结果是person2与person1的age并不相同，person1的age没有随着person2.age值的变化而变化</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型是指在操作引用类型数据时，我们实际操作的是它的引用，通过引用来间接地访问实例，一个引用类型的实例可以通过引用被持有多次，而对它生命周期的管理则使用了自动引用计数(ARC)的方式，引用类型在<code>赋值</code>、<code>传递参数</code>等过程中不会创建新的实例，而是复制了引用，这意味着，多个持有者可以共同持有一个引用类型实例，持有者之间对它的操作也会相互影响。<br>还是上面的例子，我们使用<code>class</code>来实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(age:<span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="type">Person</span>(age:<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = person1</span><br><span class="line">person2.age += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">person1.age <span class="comment">//2</span></span><br><span class="line">person2.age <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>从上面可以看出，将person1赋值给person2之后，对person2.age进行的操作影响了person1，准确的说，person1在赋值给person2时，并没有创建新的实例，而是将前一步创建的实例的<strong>引用</strong>复制了一份给person2。</p><h1 id="结构体-VS-类"><a href="#结构体-VS-类" class="headerlink" title="结构体 VS 类"></a>结构体 VS 类</h1><p>在Swift语言中使用了大量的<code>struct</code>和<code>class</code>。前文说了，结构体和类分别是值类型和引用类型。使用结构体时，往往是需要构建不可变的值，这意味着使用结构体的部分代码可以具有线程安全的特性。因为结构体是值类型，所以一个结构体实例只会有一个持有者，所以操作结构体的时候不需要考虑引用循环。</p><p>当我们在关注一个值类型实例时，我们关注的是它的值，并且它在赋值时只能复制，但是在某些情况下，我们不仅关注值，还关注实体的同一性。也就是说，我们需要确定两个变量确实是同一个实例，而非只是值相等。用银行账户打个比方，<code>a</code>账户存款100元，<code>b</code>账户存款也是100元，我们不能确定<code>a</code>账户就是<code>b</code>账户。所以在这个地方，使用结构体来构建实例我认为不太合适，使用类可以自然的判断两个变量持有的是否是同一个实例(Swift中使用<code>===</code>操作符判断两个变量是否引用的同一个实例)。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> money:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(no: <span class="type">Int</span>, cash: <span class="type">Int</span>) &#123;</span><br><span class="line">        number = no</span><br><span class="line">        money = cash</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> accountA = <span class="type">AccountClass</span>(no: <span class="number">101</span>, cash: <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">let</span> accountB = accountA</span><br><span class="line"><span class="keyword">let</span> accountC = <span class="type">AccountClass</span>(no: <span class="number">101</span>, cash: <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">accountB === accountA <span class="comment">//true</span></span><br><span class="line">accountC === accountA <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体实现</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AccountStruct</span>:<span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> money:<span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: AccountStruct, rhs: AccountStruct)</span></span> -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.money == rhs.money &amp;&amp; lhs.number == rhs.number</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> accA = <span class="type">AccountStruct</span>(number: <span class="number">101</span>, money: <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">let</span> accB = accA</span><br><span class="line"><span class="keyword">let</span> accC = <span class="type">AccountStruct</span>(number: <span class="number">101</span>, money: <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">accB == accA <span class="comment">//true</span></span><br><span class="line">accC == accA <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>上面的例子中分别使用了类和结构体来实现银行账号的定义，我们分别构造了一个类和结构体的<code>A账号</code>，再将<code>A账号</code>赋值给<code>B账号</code>，然后使用相同的初始化方式构造一个与<code>A账号</code>相同的<code>C账号</code>。这时我们可以看到使用类实现的<code>accountB</code>和<code>accountA</code>是完全相同(引用同一实例)的。而结构体本身不能使用<code>==</code>来比较，我们实现了<code>Equatable</code>这个protocol来实现了<code>==</code>这个操作符，它的实现也只能通过判断结构体属性的值来进行判断。所以当我们拿“伪造”的<code>accC</code>和原来的<code>accA</code>进行比较时，结果告诉我们：它们是相同的!</p>]]></content:encoded>
      
      <comments>https://www.hughex.com/2017/01/19/Swift%E8%BF%9B%E9%98%B6-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB/#disqus_thread</comments>
    </item>
    
    <item>
      <title>UIAccessibility初见</title>
      <link>https://www.hughex.com/2016/12/06/UIAccessibility%E5%88%9D%E8%A7%81/</link>
      <guid>https://www.hughex.com/2016/12/06/UIAccessibility%E5%88%9D%E8%A7%81/</guid>
      <pubDate>Mon, 05 Dec 2016 15:20:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;UIAccessibility&quot;&gt;&lt;a href=&quot;#UIAccessibility&quot; class=&quot;headerlink&quot; title=&quot;UIAccessibility&quot;&gt;&lt;/a&gt;UIAccessibility&lt;/h1&gt;&lt;p&gt;&lt;code&gt;UIAccessibil
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="UIAccessibility"><a href="#UIAccessibility" class="headerlink" title="UIAccessibility"></a>UIAccessibility</h1><p><code>UIAccessibility</code>是iOS下<code>UIKit</code>框架中的辅助功能(如Voice Over)的一套功能。最近在项目中曾经使用了一些这部分的功能，姑且把自己学到的一点皮毛写在这里。</p><h2 id="UIAccessibilityTraits"><a href="#UIAccessibilityTraits" class="headerlink" title="UIAccessibilityTraits"></a>UIAccessibilityTraits</h2><p><code>accessibilityLabel</code>和<code>accessibilityHint</code>这些也就不多费口舌了。我们直接来讲<code>accessibilityTraits</code>，这个属性表示在<code>Voice Over</code>下我们访问一个元素的时候，它将被作为哪种类型的对象对待。<br><code>UIAccessibilityTraits</code>是一个数值类型，它如下的所有类型都在<code>UIAccessibilityConstants.h</code>中可以找到</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Used when the element has no traits.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitNone</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Used when the element should be treated as a button.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitButton</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Used when the element should be treated as a link.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitLink</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Used when an element acts as a header for a content section (e.g. the title of a navigation bar).</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">6.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitHeader</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Used when the text field element should also be treated as a search field.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitSearchField</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Used when the element should be treated as an image. Can be combined with button or link, for example.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitImage</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Used when the element is selected.</span></span><br><span class="line"><span class="comment"> For example, a selected row in a table or a selected button within a segmented control.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitSelected</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Used when the element plays its own sound when activated.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitPlaysSound</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Used when the element acts as a keyboard key.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitKeyboardKey</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Used when the element should be treated as static text that cannot change.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitStaticText</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Used when an element can be used to provide a quick summary of current </span></span><br><span class="line"><span class="comment"> conditions in the app when the app first launches.  For example, when Weather</span></span><br><span class="line"><span class="comment"> first launches, the element with today's weather conditions is marked with</span></span><br><span class="line"><span class="comment"> this trait.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitSummaryElement</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Used when the control is not enabled and does not respond to user input.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitNotEnabled</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Used when the element frequently updates its label or value, but too often to send notifications. </span></span><br><span class="line"><span class="comment"> Allows an accessibility client to poll for changes. A stopwatch would be an example.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitUpdatesFrequently</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Used when activating an element starts a media session (e.g. playing a movie, recording audio) </span></span><br><span class="line"><span class="comment"> that should not be interrupted by output from an assistive technology, like VoiceOver.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">4.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitStartsMediaSession</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Used when an element can be "adjusted" (e.g. a slider). The element must also </span></span><br><span class="line"><span class="comment"> implement accessibilityIncrement and accessibilityDecrement.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">4.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitAdjustable</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Used when an element allows direct touch interaction for VoiceOver users (for example, a view representing a piano keyboard).</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">5.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitAllowsDirectInteraction</span>: <span class="type">UIAccessibilityTraits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Informs VoiceOver that it should scroll to the next page when it finishes reading the contents of the</span></span><br><span class="line"><span class="comment"> element. VoiceOver will scroll by calling accessibilityScroll: with UIAccessibilityScrollDirectionNext and will </span></span><br><span class="line"><span class="comment"> stop scrolling when it detects the content has not changed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">5.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="type">UIAccessibilityTraitCausesPageTurn</span>: <span class="type">UIAccessibilityTraits</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.hughex.com/2016/12/06/UIAccessibility%E5%88%9D%E8%A7%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>函数式Swift——枚举</title>
      <link>https://www.hughex.com/2016/08/18/%E5%87%BD%E6%95%B0%E5%BC%8FSwift%E2%80%94%E2%80%94%E6%9E%9A%E4%B8%BE/</link>
      <guid>https://www.hughex.com/2016/08/18/%E5%87%BD%E6%95%B0%E5%BC%8FSwift%E2%80%94%E2%80%94%E6%9E%9A%E4%B8%BE/</guid>
      <pubDate>Thu, 18 Aug 2016 03:48:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;关于枚举&quot;&gt;&lt;a href=&quot;#关于枚举&quot; class=&quot;headerlink&quot; title=&quot;关于枚举&quot;&gt;&lt;/a&gt;关于枚举&lt;/h2&gt;&lt;h3 id=&quot;OC中的枚举与Swift中的枚举&quot;&gt;&lt;a href=&quot;#OC中的枚举与Swift中的枚举&quot; class=&quot;head
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="关于枚举"><a href="#关于枚举" class="headerlink" title="关于枚举"></a>关于枚举</h2><h3 id="OC中的枚举与Swift中的枚举"><a href="#OC中的枚举与Swift中的枚举" class="headerlink" title="OC中的枚举与Swift中的枚举"></a>OC中的枚举与Swift中的枚举</h3><p><code>Objective-C</code>中的枚举类型类似于<code>NSASCIIStringEncoding</code>、<code>NSNEXTSTEPStringEncoding</code>、<code>NSJapaneseEUCStringEncoding</code>、<code>NSUTF8StringEncoding</code>酱婶儿的，用起来也是比较麻烦。</p><p>在<code>Swift</code>中，枚举出现的方式已经没有那么粗暴了，而是像<code>UIViewContentMode.Bottom</code>、<code>UIViewAnimationOptions.Autoreverse</code>这样比较温柔的方式，实际使用的时候还支持像<code>.Bottom</code>、<code>.Autoreverse</code>这样的文艺使用方法。</p><p>而且在我们实际使用枚举值的时候，枚举的定义还可以加入<code>关联值</code>、<code>泛型</code>等概念，这使得枚举的实际使用价值更加高了</p><h2 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h2><p>枚举中加入关联值的作用在于：我们在传递一个枚举值的时候，还可以同时传递一个(或多个)规定的关联值，这样我们可以通过媒体传递更多的信息。<br>比如我们要实现一个网络请求，请求的结果有<code>成功</code>和<code>失败</code>。</p><p>我们定义一个网络请求的结果枚举：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们拿到结果之后，可以知道这个结果是否成功了。但是成功之后，我的网络请求返回的数据呢？失败之后，我我是为什么失败了呢？这样只能从其他方式再去获取了，能不能值传递一个结果就能拿到我想要的这些东西呢？</p><p>似乎关联值可以：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(<span class="type">NSError</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以这样来使用这个结果:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printResult</span><span class="params">(result:Result)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> data):</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="type">Result</span>.<span class="type">Success</span>(<span class="string">"Hello World"</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="type">Result</span>.<span class="type">Failure</span>(<span class="type">NSError</span>(domain: <span class="string">"test Error"</span>, code: <span class="number">404</span>, userInfo: [<span class="string">"1234567"</span>:<span class="string">"abcdefg"</span>]))</span><br><span class="line">printResult(a) <span class="comment">// Hello World</span></span><br><span class="line">printResult(b) <span class="comment">// Error Domain=test Error Code=404 "(null)" UserInfo=&#123;1234567=abcdefg&#125;</span></span><br></pre></td></tr></table></figure><p>看起来还不错，但是每次想要取值都去<code>switch-case</code>一下还是太麻烦了，我们将它改成<code>.</code>一下就能取值的:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(<span class="type">NSError</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123; </span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> data):</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Failure</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> error: <span class="type">NSError?</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">return</span> error</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Success</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(a.data)"</span>+<span class="string">" "</span>+<span class="string">"\(a.error)"</span>) <span class="comment">//Optional("Hello World") nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(b.data)"</span>+<span class="string">" "</span>+<span class="string">"\(b.error)"</span>) <span class="comment">//nil Optional(Error Domain=test Error Code=404 "(null)" UserInfo=&#123;1234567=abcdefg&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="添加泛型"><a href="#添加泛型" class="headerlink" title="添加泛型"></a>添加泛型</h2><p>现在，一个网络请求的结果枚举就完成了，我现在还需要一个数据库请求的结果枚举，功能都差不多，只是请求成功后数据类型有点不一样，像下面这样在这个枚举中加入泛型就可以拿来用了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">Data</span>,<span class="title">Error</span>:<span class="title">ErrorType</span>&gt; </span>&#123; <span class="comment">//声明枚举时添加类型签名</span></span><br><span class="line"><span class="comment">//enum Result &#123;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(<span class="type">Data</span>)<span class="comment">//使用泛型作为关联值</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(<span class="type">Error</span>)</span><br><span class="line"><span class="comment">//    case Success(String)</span></span><br><span class="line"><span class="comment">//    case Failure(NSError)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">Data?</span> &#123;<span class="comment">//在成员和方法中也使用泛型</span></span><br><span class="line"><span class="comment">//    var data: String? &#123;</span></span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123; </span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> data):</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Failure</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> error: <span class="type">Error?</span> &#123;</span><br><span class="line"><span class="comment">//    var error: NSError? &#123;</span></span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">return</span> error</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Success</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型中的代数学"><a href="#数据类型中的代数学" class="headerlink" title="数据类型中的代数学"></a>数据类型中的代数学</h2><h3 id="同构"><a href="#同构" class="headerlink" title="同构"></a>同构</h3><blockquote><p>“比较直观的解释是，如果两个类型 A 和 B 在相互转换时不会丢失任何信息，那么它们就是同构的。”</p></blockquote><blockquote><p>摘录来自: Chris Eidhof. “函数式 Swift”。 iBooks. </p></blockquote><p>通过枚举和泛型可以定义许多代数数据类型，具有某些数学运算的特性，比如<code>加法</code>、<code>乘法</code>、<code>微分</code>、<code>积分</code></p>]]></content:encoded>
      
      <comments>https://www.hughex.com/2016/08/18/%E5%87%BD%E6%95%B0%E5%BC%8FSwift%E2%80%94%E2%80%94%E6%9E%9A%E4%B8%BE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>函数式Swift——Map、Filter、Reduce</title>
      <link>https://www.hughex.com/2016/08/01/%E5%87%BD%E6%95%B0%E5%BC%8FSwift%E2%80%94%E2%80%94Map%E3%80%81Filter%E3%80%81Reduce/</link>
      <guid>https://www.hughex.com/2016/08/01/%E5%87%BD%E6%95%B0%E5%BC%8FSwift%E2%80%94%E2%80%94Map%E3%80%81Filter%E3%80%81Reduce/</guid>
      <pubDate>Mon, 01 Aug 2016 03:23:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本篇主要解释以及模拟实现Map、Filter以及Reduce三个方法在数组操作中的作用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“接受其它函
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇主要解释以及模拟实现Map、Filter以及Reduce三个方法在数组操作中的作用</p><blockquote><p>“接受其它函数作为参数的函数有时被称为高阶函数。本章中，我们将在一些来自 Swift 标准库中作用于数组的高阶函数中漫游。伴随这个过程，我们将介绍 Swift 的泛型，以及展示如何将复杂计算运用于数组。”</p></blockquote><blockquote><p>摘录来自: Chris Eidhof. “函数式 Swift”。</p></blockquote><h1 id="泛型介绍"><a href="#泛型介绍" class="headerlink" title="泛型介绍"></a>泛型介绍</h1><p>Swift中引入了泛型的概念，这个概念在其他许多高级语言中也有。使用泛型，我们可以将原本代码中很多重复的，大量相似的代码进行抽象化。<br>具体来说，就是可以让我们设计适用于不同类型的通用函数(函数族)，例如下图：<br><img src="http://ww4.sinaimg.cn/large/6b7d44cfgw1f6e1eypvlwj20vq0b73zj.jpg" alt="image"><br>以及让我们设计泛型类，例如:<code>Array&lt;Element&gt;</code>、<code>Dictionary&lt;Key : Hashable, Value&gt;</code>、<code>Range&lt;Element : ForwardIndexType&gt;</code>等等。</p><h1 id="模拟实现Map"><a href="#模拟实现Map" class="headerlink" title="模拟实现Map"></a>模拟实现Map</h1><p>在数组中使用map函数的主要作用是对目标数组中的每个元素都进行某一个相同的操作，而这个进行的操作由map函数所接收的参数“transform: Element -&gt; T”来规定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension Array &#123;</span><br><span class="line">    func map&lt;T&gt;(transform: Element -&gt; T) -&gt; [T] &#123;</span><br><span class="line">        var result: [T] = []</span><br><span class="line">        for x in self &#123;</span><br><span class="line">            result.append(transform(x))</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中Element这个类型参数来自Array<element>的定义</element></p><p>例：当我们自己实现对某一个<code>Int</code>数组中的元素进行<code>+1</code>操作。很简单，只需要一个循环就可以完成了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func increment(xs:[Int]) -&gt; [Int]&#123;</span><br><span class="line">    var result:[Int] = []</span><br><span class="line">    for x in xs &#123;</span><br><span class="line">        result.append(x+1)</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把每个元素乘2呢？很简单，稍微修改一下就行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func double(xs:[Int]) -&gt; [Int]&#123;</span><br><span class="line">    var result:[Int] = []</span><br><span class="line">    for x in xs &#123;</span><br><span class="line">        result.append(x*2)</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设想：如果我们需要对数组中每个元素进行若干种操作，是否需要将每一种操作都以这样类似的方式来实现一遍呢？</p><p>这里我们可以引入函数式编程的思想，将要进行的操作(函数)作为参数传入函数中，做出以下实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func compute(xs:[Int],transform:Int -&gt; Int) -&gt; [Int]&#123;</span><br><span class="line">    var result:[Int] = []</span><br><span class="line">    for x in xs &#123;</span><br><span class="line">        result.append(transform(x))</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现，似乎还不完善，因为它只支持某一个整型数组中的元素进行整型到整型的操作，如果是其它类型的数组，或者需要将数组转换为其它类型的数组，则这个函数就不适用了。此处再引入泛型对这个函数进行改造，实现如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func compute&lt;Element,T&gt;(xs:[Element],transform:Element -&gt; T) -&gt; [T]&#123;</span><br><span class="line">    var result:[T] = []</span><br><span class="line">    for x in xs &#123;</span><br><span class="line">        result.append(transform(x))</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们对这个函数的通用性改造就算完成了，而它与Swift标准库中map的区别在于：map函数是协议扩展的函数，而它是顶层函数.</p><p>而它们的调用方式也不同: <code>array.map(transform)</code>、<code>compute(array, transform: transform</code>)</p><h1 id="模拟实现Filter"><a href="#模拟实现Filter" class="headerlink" title="模拟实现Filter"></a>模拟实现Filter</h1><p>Filter，顾名思义，是用来过滤数组中的元素，返回的数组中包含原数组所有符合筛选条件的元素。它的原理与Map类似，而不同之处在于：我们传入的函数，不是用作对数组本身进行操作，而是一个筛选条件，所以传入函数的返回值为一个布尔值，用于表示该元素是否符合筛选条件。它的模拟实现为如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension Array &#123;</span><br><span class="line">    func filter(includeElement: Element -&gt; Bool) -&gt; [Element] &#123;</span><br><span class="line">        var result: [Element] = []</span><br><span class="line">        for x in self where includeElement(x) &#123;</span><br><span class="line">            result.append(x)</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模拟实现Reduce"><a href="#模拟实现Reduce" class="headerlink" title="模拟实现Reduce"></a>模拟实现Reduce</h1><p>相比于Map、Filter，Reduce在我看来显得更为强大，因为Reduce不仅可以遍历数组进行运算，而且还可以记录上一步的运算结果，对于运算结果，我们更能自由地操作它。<br>这里使用一个累加数组的例子来模拟Reduce的实现，首先是for循环的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func sum(xs:[Int]) -&gt; Int&#123;</span><br><span class="line">    var result:Int = 0</span><br><span class="line">    for x in xs &#123;</span><br><span class="line">        result = result + x</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，我们引入函数式思想，将每步操作作为参数传入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func sum1(xs:[Int],transform:(Int,Int) -&gt; Int) -&gt; Int &#123;</span><br><span class="line">    var result:Int = 0</span><br><span class="line">    for x in xs &#123;</span><br><span class="line">        result = transform(result, x)</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们希望操作的数组是任意类型的，操作结果也可以返回任意类型的值，所以加入泛型,由于结果是任意类型，所以初始值需要外部传入，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func myReduce&lt;Element,T&gt;(initial:T,xs:[Element],transform:(T,Element)-&gt;T) -&gt; T &#123;</span><br><span class="line">    var result:T = initial</span><br><span class="line">    for x in xs &#123;</span><br><span class="line">        result = transform(result, x)</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及Array扩展版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension Array &#123;</span><br><span class="line">    func reduce&lt;T&gt;(initial: T, combine: (T, Element) -&gt; T) -&gt; T &#123;</span><br><span class="line">        var result = initial</span><br><span class="line">        for x in self &#123;</span><br><span class="line">            result = combine(result, x)</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>甚至我们可以使用Reduce来实现Map和Filter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extension Array &#123;</span><br><span class="line">    func mapUsingReduce&lt;T&gt;(transform: Element -&gt; T) -&gt; [T] &#123;</span><br><span class="line">        return reduce([]) &#123; result, x in</span><br><span class="line">            return result + [transform(x)]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func filterUsingReduce(includeElement: Element -&gt; Bool) -&gt; [Element] &#123;</span><br><span class="line">        return reduce([]) &#123; result, x in</span><br><span class="line">            return includeElement(x) ? result + [x] : result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://pan.baidu.com/s/1c2r4Cj2" target="_blank" rel="noopener">点我下载这部分的Playground</a></p>]]></content:encoded>
      
      <comments>https://www.hughex.com/2016/08/01/%E5%87%BD%E6%95%B0%E5%BC%8FSwift%E2%80%94%E2%80%94Map%E3%80%81Filter%E3%80%81Reduce/#disqus_thread</comments>
    </item>
    
    <item>
      <title>日本语课堂--时间/日期</title>
      <link>https://www.hughex.com/2016/07/07/%E6%97%A5%E6%9C%AC%E8%AF%AD%E8%AF%BE%E5%A0%82-%E6%97%B6%E9%97%B4-%E6%97%A5%E6%9C%9F/</link>
      <guid>https://www.hughex.com/2016/07/07/%E6%97%A5%E6%9C%AC%E8%AF%AD%E8%AF%BE%E5%A0%82-%E6%97%B6%E9%97%B4-%E6%97%A5%E6%9C%9F/</guid>
      <pubDate>Thu, 07 Jul 2016 01:52:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;生词&quot;&gt;&lt;a href=&quot;#生词&quot; class=&quot;headerlink&quot; title=&quot;生词&quot;&gt;&lt;/a&gt;生词&lt;/h2&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="生词"><a href="#生词" class="headerlink" title="生词"></a>生词</h2><a id="more"></a><h3 id="昨天今天明天-上周这周下周-上午下午早上晚上"><a href="#昨天今天明天-上周这周下周-上午下午早上晚上" class="headerlink" title="昨天今天明天/上周这周下周/上午下午早上晚上"></a>昨天今天明天/上周这周下周/上午下午早上晚上</h3><table><thead><tr><th style="text-align:center">平/片假名</th><th style="text-align:center">日语汉字</th><th style="text-align:center">中文</th></tr></thead><tbody><tr><td style="text-align:center">いま</td><td style="text-align:center">今</td><td style="text-align:center">现在</td></tr><tr><td style="text-align:center">せんしゅう</td><td style="text-align:center">先週</td><td style="text-align:center">上个星期</td></tr><tr><td style="text-align:center">らいしゅう</td><td style="text-align:center">来週</td><td style="text-align:center">下个星期</td></tr><tr><td style="text-align:center">さらいしゅう</td><td style="text-align:center">再来週</td><td style="text-align:center">下下个星期</td></tr><tr><td style="text-align:center">こんしゅう</td><td style="text-align:center">今週</td><td style="text-align:center">这个星期</td></tr><tr><td style="text-align:center">きのう</td><td style="text-align:center">昨日</td><td style="text-align:center">昨天</td></tr><tr><td style="text-align:center">あした</td><td style="text-align:center">明日</td><td style="text-align:center">明天</td></tr><tr><td style="text-align:center">あさって</td><td style="text-align:center">明後日</td><td style="text-align:center">后天</td></tr><tr><td style="text-align:center">おととい</td><td style="text-align:center"></td><td style="text-align:center">前天 </td></tr><tr><td style="text-align:center">まいにち</td><td style="text-align:center">毎日</td><td style="text-align:center">每天</td></tr><tr><td style="text-align:center">まいあさ</td><td style="text-align:center">毎朝</td><td style="text-align:center">每天早晨</td></tr><tr><td style="text-align:center">まいばん</td><td style="text-align:center">毎晩</td><td style="text-align:center">每天晚上</td></tr><tr><td style="text-align:center">まいしゅう</td><td style="text-align:center">毎週</td><td style="text-align:center">每个星期</td></tr><tr><td style="text-align:center">ごぜん</td><td style="text-align:center">午前</td><td style="text-align:center">上午</td></tr><tr><td style="text-align:center">エーエム</td><td style="text-align:center">am</td><td style="text-align:center">上午</td></tr><tr><td style="text-align:center">ごご</td><td style="text-align:center">午後</td><td style="text-align:center">下午</td></tr><tr><td style="text-align:center">ピーエム</td><td style="text-align:center">pm</td><td style="text-align:center">下午</td></tr></tbody></table><h3 id="星期"><a href="#星期" class="headerlink" title="星期"></a>星期</h3><p>在日语中，一周每天表示为从星期日开始，至星期六结束分别为<code>日、月、火、水、木、金、土</code>七个耀日</p><table><thead><tr><th style="text-align:center">平/片假名</th><th style="text-align:center">日语汉字</th><th style="text-align:center">中文</th></tr></thead><tbody><tr><td style="text-align:center">にちようび</td><td style="text-align:center">日曜日</td><td style="text-align:center">星期日</td></tr><tr><td style="text-align:center">げつようび</td><td style="text-align:center">月曜日</td><td style="text-align:center">星期一</td></tr><tr><td style="text-align:center">かようび</td><td style="text-align:center">火曜日</td><td style="text-align:center">星期二</td></tr><tr><td style="text-align:center">すいようび</td><td style="text-align:center">水曜日</td><td style="text-align:center">星期三</td></tr><tr><td style="text-align:center">もくようび</td><td style="text-align:center">木曜日</td><td style="text-align:center">星期四</td></tr><tr><td style="text-align:center">きんようび</td><td style="text-align:center">金曜日</td><td style="text-align:center">星期五</td></tr><tr><td style="text-align:center">どようび</td><td style="text-align:center">土曜日</td><td style="text-align:center">星期六</td></tr></tbody></table><h2 id="例句"><a href="#例句" class="headerlink" title="例句"></a>例句</h2><h3 id="啥时候干啥"><a href="#啥时候干啥" class="headerlink" title="啥时候干啥"></a>啥时候干啥</h3><p>A：毎日，何時に寝ますか　–每天啥时候睡</p><p>B：11時30分に寝ます –十一点半睡</p><h3 id="啥时候到啥时候干啥"><a href="#啥时候到啥时候干啥" class="headerlink" title="啥时候到啥时候干啥"></a>啥时候到啥时候干啥</h3><p>A：昨日，何時から　何時まで　働きましたか　–昨天你啥时候在上班</p><p>B：９時から　６時まで　働きました –9点到6点在上班</p><h3 id="干啥了没有"><a href="#干啥了没有" class="headerlink" title="干啥了没有"></a>干啥了没有</h3><p>A：先週　休みましたか　–你上周休息了吗</p><p>B：いいえ　休みませんでした –没有 没休息</p><h3 id="啥时候开始"><a href="#啥时候开始" class="headerlink" title="啥时候开始"></a>啥时候开始</h3><p>A：試験はいつ始まりますか　–考试啥时候开始</p><p>B：来週の木曜日です –下周四开始</p>]]></content:encoded>
      
      <comments>https://www.hughex.com/2016/07/07/%E6%97%A5%E6%9C%AC%E8%AF%AD%E8%AF%BE%E5%A0%82-%E6%97%B6%E9%97%B4-%E6%97%A5%E6%9C%9F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>日本语课堂第二日</title>
      <link>https://www.hughex.com/2016/05/30/%E6%97%A5%E6%9C%AC%E8%AF%AD%E8%AF%BE%E5%A0%82%E7%AC%AC%E4%BA%8C%E6%97%A5/</link>
      <guid>https://www.hughex.com/2016/05/30/%E6%97%A5%E6%9C%AC%E8%AF%AD%E8%AF%BE%E5%A0%82%E7%AC%AC%E4%BA%8C%E6%97%A5/</guid>
      <pubDate>Mon, 30 May 2016 02:56:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;坑了两个月回来填坑了。。。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>坑了两个月回来填坑了。。。<br> <a id="more"></a></p><h2 id="五十音图补完计划"><a href="#五十音图补完计划" class="headerlink" title="五十音图补完计划"></a>五十音图补完计划</h2><h3 id="さ行"><a href="#さ行" class="headerlink" title="さ行"></a>さ行</h3><table><thead><tr><th>罗马音</th><th>sa</th><th>shi</th><th>su</th><th>se</th><th>so</th></tr></thead><tbody><tr><td>平假名</td><td>さ</td><td>し</td><td>す</td><td>せ</td><td>そ</td></tr><tr><td>片假名</td><td>サ</td><td>シ</td><td>ス</td><td>セ</td><td>ソ</td></tr></tbody></table><h3 id="た行"><a href="#た行" class="headerlink" title="た行"></a>た行</h3><table><thead><tr><th>罗马音</th><th>ta</th><th>chi</th><th>tsu</th><th>te</th><th>to</th></tr></thead><tbody><tr><td>平假名</td><td>た</td><td>ち</td><td>つ</td><td>て</td><td>と</td></tr><tr><td>片假名</td><td>タ</td><td>チ</td><td>ツ</td><td>テ</td><td>ト</td></tr></tbody></table><h3 id="な行"><a href="#な行" class="headerlink" title="な行"></a>な行</h3><table><thead><tr><th>罗马音</th><th>na</th><th>ni</th><th>nu</th><th>ne</th><th>no</th></tr></thead><tbody><tr><td>平假名</td><td>な</td><td>に</td><td>ぬ</td><td>ね</td><td>の</td></tr><tr><td>片假名</td><td>ナ</td><td>ニ</td><td>ヌ</td><td>ネ</td><td>ノ</td></tr></tbody></table><h3 id="は行"><a href="#は行" class="headerlink" title="は行"></a>は行</h3><table><thead><tr><th>罗马音</th><th>ha</th><th>hi</th><th>fu</th><th>he</th><th>ho</th></tr></thead><tbody><tr><td>平假名</td><td>は</td><td>ひ</td><td>ふ</td><td>へ</td><td>ほ</td></tr><tr><td>片假名</td><td>ハ</td><td>ヒ</td><td>フ</td><td>ヘ</td><td>ホ</td></tr></tbody></table><h3 id="ま行"><a href="#ま行" class="headerlink" title="ま行"></a>ま行</h3><table><thead><tr><th>罗马音</th><th>ma</th><th>mi</th><th>mu</th><th>me</th><th>mo</th></tr></thead><tbody><tr><td>平假名</td><td>ま</td><td>み</td><td>む</td><td>め</td><td>も</td></tr><tr><td>片假名</td><td>マ</td><td>ミ</td><td>ム</td><td>メ</td><td>モ</td></tr></tbody></table><h3 id="や行"><a href="#や行" class="headerlink" title="や行"></a>や行</h3><table><thead><tr><th>罗马音</th><th>ya</th><th>(i)</th><th>yu</th><th>(e)</th><th>yo</th></tr></thead><tbody><tr><td>平假名</td><td>や</td><td>(い)</td><td>ゆ</td><td>(え)</td><td>よ</td></tr><tr><td>片假名</td><td>ヤ</td><td>(イ)</td><td>ユ</td><td>(エ)</td><td>ヨ</td></tr></tbody></table><h3 id="ら行"><a href="#ら行" class="headerlink" title="ら行"></a>ら行</h3><table><thead><tr><th>罗马音</th><th>ra</th><th>ri</th><th>ru</th><th>re</th><th>ro</th></tr></thead><tbody><tr><td>平假名</td><td>ら</td><td>り</td><td>る</td><td>れ</td><td>ろ</td></tr><tr><td>片假名</td><td>ラ</td><td>リ</td><td>ル</td><td>レ</td><td>ロ</td></tr></tbody></table><h3 id="わ行"><a href="#わ行" class="headerlink" title="わ行"></a>わ行</h3><table><thead><tr><th>罗马音</th><th>wa</th><th>(i)</th><th>(u)</th><th>(e)</th><th>o</th></tr></thead><tbody><tr><td>平假名</td><td>わ</td><td>(い)</td><td>(う)</td><td>(え)</td><td>を</td></tr><tr><td>片假名</td><td>ワ</td><td>(イ)</td><td>(ウ)</td><td>(エ)</td><td>ヲ</td></tr></tbody></table><h3 id="ん"><a href="#ん" class="headerlink" title="ん"></a>ん</h3><table><thead><tr><th>罗马音</th><th>n</th></tr></thead><tbody><tr><td>平假名</td><td>ん</td></tr><tr><td>片假名</td><td>ン</td></tr></tbody></table><h2 id="真·五十音图"><a href="#真·五十音图" class="headerlink" title="真·五十音图"></a>真·五十音图</h2><p><img src="http://ww4.sinaimg.cn/mw690/6b7d44cfjw1f4dab18n3aj20ri0j513f.jpg" alt></p><p><a href="http://jp.hjenglish.com/subject/pronounce/" target="_blank" rel="noopener">沪江五十音</a></p>]]></content:encoded>
      
      <comments>https://www.hughex.com/2016/05/30/%E6%97%A5%E6%9C%AC%E8%AF%AD%E8%AF%BE%E5%A0%82%E7%AC%AC%E4%BA%8C%E6%97%A5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>日本语课堂第一日</title>
      <link>https://www.hughex.com/2016/04/07/%E6%97%A5%E6%9C%AC%E8%AF%AD%E8%AF%BE%E5%A0%82%E7%AC%AC%E4%B8%80%E6%97%A5/</link>
      <guid>https://www.hughex.com/2016/04/07/%E6%97%A5%E6%9C%AC%E8%AF%AD%E8%AF%BE%E5%A0%82%E7%AC%AC%E4%B8%80%E6%97%A5/</guid>
      <pubDate>Thu, 07 Apr 2016 06:54:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;日语文字的组成&quot;&gt;&lt;a href=&quot;#日语文字的组成&quot; class=&quot;headerlink&quot; title=&quot;日语文字的组成&quot;&gt;&lt;/a&gt;日语文字的组成&lt;/h2&gt;&lt;p&gt;日语文字  = （假名 = 平假名 + 片假名） + 汉字&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="日语文字的组成"><a href="#日语文字的组成" class="headerlink" title="日语文字的组成"></a>日语文字的组成</h2><p>日语文字  = （假名 = 平假名 + 片假名） + 汉字</p><a id="more"></a><h2 id="五十音图"><a href="#五十音图" class="headerlink" title="五十音图"></a>五十音图</h2><h3 id="あ行"><a href="#あ行" class="headerlink" title="あ行"></a>あ行</h3><table><thead><tr><th>罗马音</th><th>a</th><th>i</th><th>u</th><th>e</th><th>o</th></tr></thead><tbody><tr><td>平假名</td><td>あ</td><td>い</td><td>う</td><td>え</td><td>お</td></tr><tr><td>片假名</td><td>ア</td><td>イ</td><td>ウ</td><td>エ</td><td>オ</td></tr></tbody></table><h3 id="か行"><a href="#か行" class="headerlink" title="か行"></a>か行</h3><table><thead><tr><th>罗马音</th><th>ka</th><th>ki</th><th>ku</th><th>ke</th><th>ko</th></tr></thead><tbody><tr><td>平假名</td><td>か</td><td>き</td><td>く</td><td>け</td><td>こ</td></tr><tr><td>片假名</td><td>カ</td><td>キ</td><td>ク</td><td>ケ</td><td>コ</td></tr></tbody></table><h2 id="日常用语"><a href="#日常用语" class="headerlink" title="日常用语"></a>日常用语</h2><table><thead><tr><th>罗马音</th><th>o ha yo u</th></tr></thead><tbody><tr><td>日语</td><td>お早よう</td></tr><tr><td>中文翻译</td><td>早上好</td></tr></tbody></table><table><thead><tr><th>罗马音</th><th>ko n ni chi wa</th></tr></thead><tbody><tr><td>日语</td><td>こんにちは</td></tr><tr><td>中文翻译</td><td>中午\下午好</td></tr></tbody></table><ul><li>这里は发wa音</li></ul><table><thead><tr><th>罗马音</th><th>a ri ga to u</th><th>go za i ma su</th></tr></thead><tbody><tr><td>日语</td><td>ありがとう</td><td>ございます</td></tr><tr><td>中文翻译</td><td>谢谢</td><td>（敬语）</td></tr></tbody></table>]]></content:encoded>
      
      <comments>https://www.hughex.com/2016/04/07/%E6%97%A5%E6%9C%AC%E8%AF%AD%E8%AF%BE%E5%A0%82%E7%AC%AC%E4%B8%80%E6%97%A5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ReactiveCocoa4基本操作</title>
      <link>https://www.hughex.com/2016/04/06/ReactiveCocoa4%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <guid>https://www.hughex.com/2016/04/06/ReactiveCocoa4%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Wed, 06 Apr 2016 04:06:00 GMT</pubDate>
      <description>
      
        &lt;p&gt; 本文主要提一些在ReactiveCocoa4中主要的操作，主要包括   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;observe&lt;/li&gt;
&lt;li&gt;on&lt;/li&gt;
&lt;li&gt;lift&lt;/li&gt;
&lt;li&gt;map&lt;/li&gt;
&lt;li&gt;filter&lt;/li&gt;
&lt;li&gt;reduce
      
      </description>
      
      <content:encoded><![CDATA[<p> 本文主要提一些在ReactiveCocoa4中主要的操作，主要包括   </p><ul><li>observe</li><li>on</li><li>lift</li><li>map</li><li>filter</li><li>reduce<a id="more"></a></li></ul><h2 id="对事件流产生副作用-Performing-side-effects-with-event-streams"><a href="#对事件流产生副作用-Performing-side-effects-with-event-streams" class="headerlink" title="对事件流产生副作用(Performing side effects with event streams)"></a>对事件流产生副作用(Performing side effects with event streams)</h2><h3 id="observe-观察"><a href="#observe-观察" class="headerlink" title="observe(观察)"></a>observe(观察)</h3><p><strong><code>Observer(观察者)</code></strong>可以对<strong><code>Signals(信号)</code></strong>进行<strong><code>Observe(观察)</code></strong>操作，观察这个信号将来每次发送的事件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">signal.observe(<span class="type">Signal</span>.<span class="type">Observer</span> &#123; event <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">switch</span> event &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Next</span>(next):</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"Next: (next)"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Failed</span>(error):</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"Failed: (error)"</span>)</span><br><span class="line">  <span class="keyword">case</span> .<span class="type">Completed</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"Completed"</span>)</span><br><span class="line">  <span class="keyword">case</span> .<span class="type">Interrupted</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"Interrupted"</span>)</span><br><span class="line">&#125;&#125;)</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以看到，事件一共有<strong><code>Next</code></strong>、<strong><code>Failed</code></strong>、<strong><code>Completed</code></strong>、<strong><code>Interrupted</code></strong>四种。当信号发送事件时，就会触发相应的回调。设置回调的方法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">signal.observeNext &#123; next <span class="keyword">in</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">"Next: (next)"</span>) &#125;</span><br><span class="line">signal.observeFailed &#123; error <span class="keyword">in</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">"Failed: (error)"</span>)&#125;</span><br><span class="line">signal.observeCompleted &#123; </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Completed"</span>) &#125;</span><br><span class="line">signal.observeInterrupted &#123; </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Interrupted"</span>)&#125;</span><br></pre></td></tr></table></figure><p>最后，<strong>你可以只关注你关心的事件而不必观察所有类型。</strong></p><h2 id="注入影响（Injecting-effects）"><a href="#注入影响（Injecting-effects）" class="headerlink" title="注入影响（Injecting effects）"></a>注入影响（Injecting effects）</h2><h3 id="on"><a href="#on" class="headerlink" title="on"></a>on</h3><p>通过<code>on</code>操作可以用来观察<code>SignalProducer</code>,即使没有<strong><code>订阅者</code></strong>也可以触发回调，像下面这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> producer = signalProducer </span><br><span class="line">.on(started: &#123; </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Started"</span>) </span><br><span class="line">&#125;, event: &#123; event <span class="keyword">in</span> </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Event: (event)"</span>) </span><br><span class="line">&#125;, failed: &#123; error <span class="keyword">in</span> </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Failed: (error)"</span>)</span><br><span class="line"> &#125;, completed: &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Completed"</span>)</span><br><span class="line"> &#125;, interrupted: &#123; </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Interrupted"</span>)</span><br><span class="line"> &#125;, terminated: &#123; </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Terminated"</span>) </span><br><span class="line">&#125;, disposed: &#123; </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Disposed"</span>)</span><br><span class="line"> &#125;, next: &#123; value <span class="keyword">in</span> </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Next: (value)"</span>)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>而与<code>Observer</code>观察<code>Signal</code>不同的是，<code>producer</code>需要在<strong>started</strong>之后才能触发。</p><h2 id="操作符合成-Operator-composition"><a href="#操作符合成-Operator-composition" class="headerlink" title="操作符合成(Operator composition)"></a>操作符合成(Operator composition)</h2><h2 id="lift"><a href="#lift" class="headerlink" title="lift"></a>lift</h2><p>通过<strong><code>lift</code></strong>操作可以将<strong><code>Signal</code></strong>的操作符向上迁移至<strong><code>SignalProducer</code></strong>，产生一个新的<code>SignalProducer</code>，在其产生的每个<code>Signal</code>中应用该操作符。</p><h2 id="Map-映射-、Filter-过滤-、Reduce-聚集-–转换事件流-Transforming-event-streams"><a href="#Map-映射-、Filter-过滤-、Reduce-聚集-–转换事件流-Transforming-event-streams" class="headerlink" title="Map(映射)、Filter(过滤)、Reduce(聚集) –转换事件流(Transforming event streams)"></a>Map(映射)、Filter(过滤)、Reduce(聚集) –转换事件流(Transforming event streams)</h2><h3 id="Map映射"><a href="#Map映射" class="headerlink" title="Map映射"></a>Map映射</h3><p>使用<strong><code>map</code></strong>操作可以将事件流进行转换，将原来的值进行改变等操作后产生一个新的事件流、例如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (signal, observer) = <span class="type">Signal</span>&lt;<span class="type">String</span>, <span class="type">NoError</span>&gt;.pipe()</span><br><span class="line">signal</span><br><span class="line"> .<span class="built_in">map</span> &#123; string <span class="keyword">in</span> string.uppercaseString &#125;</span><br><span class="line"> .observeNext &#123; next <span class="keyword">in</span> <span class="built_in">print</span>(next) &#125;</span><br><span class="line">observer.sendNext(<span class="string">"a"</span>) <span class="comment">// Prints A</span></span><br><span class="line">observer.sendNext(<span class="string">"b"</span>) <span class="comment">// Prints B</span></span><br><span class="line">observer.sendNext(<span class="string">"c"</span>) <span class="comment">// Prints C</span></span><br></pre></td></tr></table></figure></p><h3 id="Filter过滤"><a href="#Filter过滤" class="headerlink" title="Filter过滤"></a>Filter过滤</h3><p><strong><code>filter</code></strong>顾名思义，可以对信号进行过滤，只传递满足条件的值。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let (signal, observer) = Signal&lt;Int, NoError&gt;.pipe()</span><br><span class="line">signal </span><br><span class="line">.filter &#123; number in number % 2 == 0 &#125;</span><br><span class="line"> .observeNext &#123; next in print(next) &#125;</span><br><span class="line">observer.sendNext(1) // Not printed</span><br><span class="line">observer.sendNext(2) // Prints 2</span><br><span class="line">observer.sendNext(3) // Not printed</span><br><span class="line">observer.sendNext(4) // prints 4</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，条件为<code>filter { number in number % 2 == 0 }</code>,表示符合条件的值为能被2整除的数，则<code>1</code>和<code>3</code>被过滤掉了，观察者不会观察到这两个<code>Next</code>事件。</p><h3 id="Aggregate聚集"><a href="#Aggregate聚集" class="headerlink" title="Aggregate聚集"></a>Aggregate聚集</h3><p><strong><code>reduce</code></strong>可以将某一<code>事件</code>的值聚集后合成为一个新值，在输入的流结束后发送。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let (signal, observer) = Signal&lt;Int, NoError&gt;.pipe()</span><br><span class="line">signal .reduce(1) &#123; $0 * $1 &#125; </span><br><span class="line">.observeNext &#123; next in print(next) &#125;</span><br><span class="line">observer.sendNext(1) // nothing printed</span><br><span class="line">observer.sendNext(2) // nothing printed</span><br><span class="line">observer.sendNext(3) // nothing printed</span><br><span class="line">observer.sendCompleted() // prints 6</span><br></pre></td></tr></table></figure></p><p><strong><code>collect</code></strong>操作可以将一个事件流的值聚合为一个单个的数组值，在输入流结束后发送。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let (signal, observer) = Signal&lt;Int, NoError&gt;.pipe()</span><br><span class="line"></span><br><span class="line">signal</span><br><span class="line">    .collect()</span><br><span class="line">    .observeNext &#123; next in print(next) &#125;</span><br><span class="line"></span><br><span class="line">observer.sendNext(1)     // nothing printed</span><br><span class="line">observer.sendNext(2)     // nothing printed</span><br><span class="line">observer.sendNext(3)     // nothing printed</span><br><span class="line">observer.sendCompleted()   // prints [1, 2, 3]</span><br></pre></td></tr></table></figure><p>附上一个网址，以图案的方式展示了很多RAC信号的操作<a href="http://neilpa.me/rac-marbles/" target="_blank" rel="noopener">http://neilpa.me/rac-marbles/</a><br>更多资料：<br>    <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/tree/master/Documentation" target="_blank" rel="noopener">ReactiveCocoa 4官方文档</a></p>]]></content:encoded>
      
      <comments>https://www.hughex.com/2016/04/06/ReactiveCocoa4%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ReactiveCocoa(RAC)</title>
      <link>https://www.hughex.com/2015/11/09/RAC-Reactive-Cocoa/</link>
      <guid>https://www.hughex.com/2015/11/09/RAC-Reactive-Cocoa/</guid>
      <pubDate>Sun, 08 Nov 2015 20:45:39 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;–-基于响应式编程的第三方框架&quot;&gt;&lt;a href=&quot;#–-基于响应式编程的第三方框架&quot; class=&quot;headerlink&quot; title=&quot;– 基于响应式编程的第三方框架&quot;&gt;&lt;/a&gt;– 基于响应式编程的第三方框架&lt;/h2&gt;&lt;h3 id=&quot;函数响应式编程-FRP&quot;&gt;&lt;a href=&quot;#函数响应式编程-FRP&quot; class=&quot;headerlink&quot; title=&quot;函数响应式编程 (FRP)&quot;&gt;&lt;/a&gt;函数响应式编程 (FRP)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;一种和事件流有关的编程模式，关注导致状态值改变的行为事件，一系列的事件组成了事件流。
&lt;/code&gt;&lt;/pre&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="–-基于响应式编程的第三方框架"><a href="#–-基于响应式编程的第三方框架" class="headerlink" title="– 基于响应式编程的第三方框架"></a>– 基于响应式编程的第三方框架</h2><h3 id="函数响应式编程-FRP"><a href="#函数响应式编程-FRP" class="headerlink" title="函数响应式编程 (FRP)"></a>函数响应式编程 (FRP)</h3><pre><code>一种和事件流有关的编程模式，关注导致状态值改变的行为事件，一系列的事件组成了事件流。</code></pre><a id="more"></a><h4 id="思想示例-C-A-B-（编程代码）"><a href="#思想示例-C-A-B-（编程代码）" class="headerlink" title="思想示例: C =    A    +    B （编程代码）"></a>思想示例: C =    A    +    B （编程代码）</h4><pre><code>使用FRP ：C值依赖于A和B的值程序运行过程中：1.初始化 A = 1 ， B = 2 时 C = 32.程序运行过程中，若A值发生改变 A =  2 ，那C也将对应改变   C = 43.运行过程中，若B值发生改变 B = 5 ，那C 对应改变  C = 7 </code></pre><h3 id="RAC试图解决的问题"><a href="#RAC试图解决的问题" class="headerlink" title="RAC试图解决的问题"></a>RAC试图解决的问题</h3><ul><li>传统 iOS 开发过程中，状态以及状态之间依赖过多的问题</li><li>传统 MVC 架构的问题：Controller 比较复杂，可测试性差</li><li>提供统一的消息传递机制</li></ul><h3 id="RAC核心概念"><a href="#RAC核心概念" class="headerlink" title="RAC核心概念"></a>RAC核心概念</h3><ul><li>Signal(信号)<ul><li>Completer(完成)</li><li>Error(错误)</li></ul></li><li>Subscribe(订阅)<ul><li>Next（下一步)</li></ul></li></ul><h3 id="RAC基本使用"><a href="#RAC基本使用" class="headerlink" title="RAC基本使用"></a>RAC基本使用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITextField</span> *textField = [[<span class="built_in">UITextField</span> alloc] init];</span><br><span class="line"><span class="comment">//创建文本信号并订阅，若产生信号则执行next事件(block内容)</span></span><br><span class="line">[textField.rac_textSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="comment">//code...</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="RAC-Next事件的限制和内容转化"><a href="#RAC-Next事件的限制和内容转化" class="headerlink" title="RAC Next事件的限制和内容转化"></a>RAC Next事件的限制和内容转化</h3><ul><li>Map(转化)<br>可以将信号内容转化为任意对象</li><li>Filter(过滤)<br>设置Next执行的要求</li></ul><h3 id="RAC相关资源链接"><a href="#RAC相关资源链接" class="headerlink" title="RAC相关资源链接"></a>RAC相关资源链接</h3><ul><li>这样好用的ReactiveCocoa，根本停不下来<br><a href="http://www.cocoachina.com/ios/20150817/13071.htm" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20150817/13071.htm</a></li><li>ReactiveCocoa2实战<br><a href="http://www.cocoachina.com/industry/20140609/8737.html" target="_blank" rel="noopener">http://www.cocoachina.com/industry/20140609/8737.html</a></li><li>ReactiveCocoa2 源码浅析<br><a href="http://www.cocoachina.com/ios/20150827/13252.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20150827/13252.html</a></li><li>ReactiveCocoa底层实现解析<br><a href="http://blog.sunnyxx.com/tags/Reactive%20Cocoa%20Tutorial/" target="_blank" rel="noopener">http://blog.sunnyxx.com/tags/Reactive%20Cocoa%20Tutorial/</a></li><li>Limboy博客，内容质量高<br><a href="http://limboy.me" target="_blank" rel="noopener">http://limboy.me</a></li><li>细说ReactiveCocoa的冷信号与热信号(系列文章)<br><a href="http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-1.html" target="_blank" rel="noopener">http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-1.html</a></li></ul>]]></content:encoded>
      
      <comments>https://www.hughex.com/2015/11/09/RAC-Reactive-Cocoa/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git的使用</title>
      <link>https://www.hughex.com/2015/11/06/Git%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <guid>https://www.hughex.com/2015/11/06/Git%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Fri, 06 Nov 2015 04:37:16 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;显示Mac隐藏文件：&quot;&gt;&lt;a href=&quot;#显示Mac隐藏文件：&quot; class=&quot;headerlink&quot; title=&quot;显示Mac隐藏文件：&quot;&gt;&lt;/a&gt;显示Mac隐藏文件：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;defaults write com.apple.finder AppleShowAllFiles Yes &amp;amp;&amp;amp; killall Finder
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;隐藏Mac隐藏文件：&quot;&gt;&lt;a href=&quot;#隐藏Mac隐藏文件：&quot; class=&quot;headerlink&quot; title=&quot;隐藏Mac隐藏文件：&quot;&gt;&lt;/a&gt;隐藏Mac隐藏文件：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;defaults write com.apple.finder AppleShowAllFiles No &amp;amp;&amp;amp; killall Finder
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;git全局配置文件：&quot;&gt;&lt;a href=&quot;#git全局配置文件：&quot; class=&quot;headerlink&quot; title=&quot;git全局配置文件：&quot;&gt;&lt;/a&gt;git全局配置文件：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;~/.gitconfig
&lt;/code&gt;&lt;/pre&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="显示Mac隐藏文件："><a href="#显示Mac隐藏文件：" class="headerlink" title="显示Mac隐藏文件："></a>显示Mac隐藏文件：</h1><pre><code>defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder</code></pre><h1 id="隐藏Mac隐藏文件："><a href="#隐藏Mac隐藏文件：" class="headerlink" title="隐藏Mac隐藏文件："></a>隐藏Mac隐藏文件：</h1><pre><code>defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder</code></pre><h1 id="git全局配置文件："><a href="#git全局配置文件：" class="headerlink" title="git全局配置文件："></a>git全局配置文件：</h1><pre><code>~/.gitconfig</code></pre><a id="more"></a><h1 id="git主要指令学习"><a href="#git主要指令学习" class="headerlink" title="git主要指令学习"></a>git主要指令学习</h1><ol><li>git status 查看仓库当前状态</li><li>git add . 添加文件到“暂存区”</li><li>git commit -m “注释” 文件添加文件到本地仓库</li><li>git log 查看当前版本</li><li>git reflog 查看所有修改版本</li><li>git clone 远程仓库地址 克隆远程仓库</li><li>未提交的反悔：git reset –hard HEAD</li><li>配置带颜色的log别名 git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit” </li><li><p>git reset 版本回滚</p><pre><code>1) 回滚到上一个版本: git reset --hard HEAD^2) 回滚到上上一个版本: git reset --hard HEAD^^3) 回滚到上N个版本: git reset --hard HEAD~N(N是一个整数)4) 回滚到任意一个版本: git reset ––hard 版本号（版本号用7位即可)</code></pre><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><pre><code>5) git branch -r 查看远程分支6) git branch dev       创建分支dev分支   7）it checkout dev       切换到dev分支   8）git branch -r -d origin/bugfix1.0 删除远程分支  9）git branch   查看分支  10）git merge dev</code></pre><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><pre><code>1）git tag  查看当前标签   2)git tag -a v1.0 -m &apos;Version 1.0’ 在本地代码库给项目打上一个标签，之后记得push到服务器   3)git push origin v1.0  将标签添推送到远程代码库中   4)git checkout v1.0  签出v1.0标签   5)git checkout -b bugfix1.0 从签出状态创建v1.0bugfix分支</code></pre></li></ol><h1 id="代码托管网站"><a href="#代码托管网站" class="headerlink" title="代码托管网站"></a>代码托管网站</h1><p> 远程服务器仓库的搭建</p><h3 id="国外"><a href="#国外" class="headerlink" title="国外"></a>国外</h3><pre><code>1、https://github.com</code></pre><h3 id="国内"><a href="#国内" class="headerlink" title="国内"></a>国内</h3><pre><code>   1、https://git.oschina.net    网速较国外快，可以添加私有库中文，容易看懂     2、https://coding.net/</code></pre><h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><p><img src="http://ww2.sinaimg.cn/large/6b7d44cfgw1exr2ms8xyuj215o0nbae0.jpg" alt="1"><br><img src="http://ww3.sinaimg.cn/large/6b7d44cfgw1exr32gfvu7j20ep0jtdhk.jpg" alt="2"></p>]]></content:encoded>
      
      <comments>https://www.hughex.com/2015/11/06/Git%E7%9A%84%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
